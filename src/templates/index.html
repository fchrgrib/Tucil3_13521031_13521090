<!DOCTYPE html>
<html>
<head>
  <title>Google Maps Example</title>
  <style>
    .content-container {
        width: 73%;
        float: right;
    }

    #map {
        height: 500px;
        width: 100%;
    }

    .search-container {
        display: flex;
        justify-content: center;
        margin-top: 10px;
        margin-bottom: 10px;
    }

    #search-input {
        width: 300px;
        height: 30px;
        padding: 5px;
        border-radius: 5px;
        border: 1px solid gray;
        font-size: 16px;
    }

    .blue-div {
        position: fixed;
        top: 0;
        left: 0;
        width: 26%;
        height: 100%;
        background-color: #96b9f2;
    }

  </style>
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDQJmZwmhm1cKSMQ08x_vcSZdhdNmB3dWI"></script>
  <script>
    var markers = [];
    var clickedMarkers = [];
    var lines = [];

    function initMap() {
        var infoWindow = new google.maps.InfoWindow();
        var map = new google.maps.Map(document.getElementById('map'), {
            zoom: 18,
            center: {lat:  -6.89044875, lng: 107.6103135},
            disableDoubleClickZoom: true, // disables zooming on double-click
            clickableIcons: false
        });

        const searchInput = document.getElementById("search-input");
        const searchButton = document.getElementById("search-button");
        
        searchButton.addEventListener("click", () => {
            const geocoder = new google.maps.Geocoder();
            geocoder.geocode({ address: searchInput.value }, (results, status) => {
            if (status === "OK") {
                map.setCenter(results[0].geometry.location);
                map.setZoom(18);
            } else {
                alert("Geocode was not successful for the following reason: " + status);
            }
            });
        });

        map.addListener("dblclick", (e) => {
            var marker = new google.maps.Marker({
                position: e.latLng,
                map: map,
                id: markers.length
            });

            marker.addListener('click', function() {
                addClickedMarker(marker);
            });

            // add a double-click listener to the marker to delete marker
            marker.addListener('rightclick', function() {
                deleteLineWithMarker(marker);
                marker.setMap(null);  // remove the marker from the map
                // Remove the marker from the array
                var index = markers.indexOf(marker);
                if (index > -1) {
                    markers.splice(index, 1);
                }
                // Remove the marker from the clickedArray
                var index = clickedMarkers.indexOf(marker);
                if (index > -1) {
                    clickedMarkers.splice(index, 1);
                }

                resetMarkerId();
            });

            // Add a listener for the mouseover event to check id
            marker.addListener("mouseover", function() {
                // Set the content of the info window
                infoWindow.setContent('Marker ID: ' + marker.id);
                // Open the info window on the map
                infoWindow.open(map, marker);
            });

            // Add a listener for the mouseout event
            marker.addListener("mouseout", function() {
                infoWindow.close();
            });

            markers.push(marker);
        });
        

        function addClickedMarker(marker) {
            if(clickedMarkers.length > 0){
                if(clickedMarkers[0] != marker){
                    clickedMarkers.push(marker);
                }
            } else {
                clickedMarkers.push(marker);
            }
            if (clickedMarkers.length > 1) {
                var lastMarker = clickedMarkers[clickedMarkers.length - 2];
                var checker = lineExists(marker, lastMarker);
                if(checker == -1){
                    var line = new google.maps.Polyline({
                        path: [lastMarker.getPosition(), marker.getPosition()],
                        strokeColor: '#000000',
                        map: map
                    });

                    line.addListener('mouseover', function(event) {

                        // Calculate the length of the line
                        var length = google.maps.geometry.spherical.computeLength(line.getPath());

                        infoWindow.setContent('Length: ' + length.toFixed(2) + ' meters');

                        // Position the info window at the mouse pointer and open it
                        infoWindow.setPosition(event.latLng);
                        infoWindow.open(map);
                    });

                    line.addListener('mouseout', function() {
                        infoWindow.close();
                    });

                    lines.push(line);
                }  else {
                    // Remove the line from the map
                    lines[checker].setMap(null);
                    // Remove the line from the lines array
                    lines.splice(checker, 1);
                }

                clickedMarkers = [];
            }
        }

    }

    function clearMap() {
        // Remove all markers from map and reset markers array
        markers.forEach(function(marker) {
            marker.setMap(null);
        });
        markers = [];

        // Remove all lines from map and reset lines array
        lines.forEach(function(line) {
            line.setMap(null);
        });
        lines = [];
        clickedMarkers = [];
        clearInput();
        const runtime = document.getElementById('runtime');
        runtime.textContent = "";
    }

    function lineExists(marker1, marker2) {
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (
                (line.getPath().getAt(0).equals(marker1.getPosition()) &&
                line.getPath().getAt(1).equals(marker2.getPosition())) ||
                (line.getPath().getAt(1).equals(marker1.getPosition()) &&
                line.getPath().getAt(0).equals(marker2.getPosition()))
            ) {
                return i;
            }
        }
            return -1;
    }

    function changeLineColor(marker1, marker2) {
        for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (
                (line.getPath().getAt(0).equals(marker1.getPosition()) &&
                line.getPath().getAt(1).equals(marker2.getPosition())) ||
                (line.getPath().getAt(1).equals(marker1.getPosition()) &&
                line.getPath().getAt(0).equals(marker2.getPosition()))
            ) {
            line.setOptions({ strokeColor: '#FF0000' });
            break;
            }
        }
    }

    function deleteLineWithMarker(marker) {
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const path = line.getPath();
            for (let j = 0; j < path.getLength(); j++) {
                if (marker.getPosition().equals(path.getAt(j))) {
                    line.setMap(null);
                    lines.splice(i, 1);

                    i--;
                }
            }
        }
    }

    function resetMarkerId(){
        for (let i = 0; i < markers.length; i++) {
            markers[i].id = i;
        }
    }

    function resetLineColor(){
        lines.forEach(line => {
            line.setOptions({ strokeColor: '#000000' });
        });
    }

    

    function getAdjacencyMatrix() {
        var adjacencyMatrix = Array(markers.length).fill().map(() => Array(markers.length).fill(0));
        for(let i = 0; i < markers.length; i++){
            for(let j = i + 1; j < markers.length; j++){
                if(lineExists(markers[i], markers[j]) != -1){
                    adjacencyMatrix[i][j] = google.maps.geometry.spherical
                                            .computeDistanceBetween(markers[i].getPosition(), markers[j].getPosition());
                    adjacencyMatrix[j][i] = adjacencyMatrix[i][j];
                } else {
                    adjacencyMatrix[i][j] = -1 * google.maps.geometry.spherical
                                            .computeDistanceBetween(markers[i].getPosition(), markers[j].getPosition());
                    adjacencyMatrix[j][i] = adjacencyMatrix[i][j];
                }
            }
        }

        console.log(adjacencyMatrix);

        return adjacencyMatrix;
    }

    function showPath(data) {
        // process the integer array as needed
        if(data.length > 1){
            for(let i = 0; i < data.length - 1; i++) {
                changeLineColor(markers[data[i]], markers[data[i+1]]);
            }
        }       
    }

    function clearInput() {
        document.getElementById("destination").value = "";
        document.getElementById("origin").value = "";
    }

    function calculate(){
        var ucs = document.getElementById("UCS").checked;
        let originTextbox = document.getElementById("origin"); // Get the origin textbox element
        let origin = originTextbox.value.trim(); // Get the value of the origin textbox and remove leading/trailing whitespace

        let destinationTextbox = document.getElementById("destination"); // Get the destination textbox element
        let destination = destinationTextbox.value.trim();

        if (origin === "" || destination == "") {
        // If the textbox is empty
            alert("Please fill in the origin textbox.");
        } else {
        // If the textbox is not empty
            resetLineColor();
            var adjacencyMatrix = getAdjacencyMatrix();

            fetch('/calculate', {
                method: 'POST',
                body: JSON.stringify({adjacencyMatrix: adjacencyMatrix,
                                    origin: origin,
                                    destination: destination,
                                    ucs: ucs}),
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                showPath(data.index_array);
                const runtime = document.getElementById('runtime');
                runtime.textContent = "calculation time : " + data.runtime.toFixed(5) + " ms.";
            })
            .catch(error => console.error(error));
        }
    }

  </script>
</head>
<body onload="initMap()">
    <div id="main-container" class="content-container">
        <div id="search-box" class="search-container">
            <input type="text" id="search-input" placeholder="Search">
            <button id="search-button">Go</button>
        </div>
        <div id="map"></div>
        
        <div class="search-container" id="input">
            <label for="origin">Origin:</label>
            <input type="text" id="origin" name="origin" placeholder="Enter origin" style="margin-right: 10px;">
            
            <label for="destination" style="margin-left: 10px;">Destination:</label>
            <input type="text" id="destination" name="destination" placeholder="Enter destination">
        </div>
        <div class="search-container" id="options">
            <label>
            <input type="radio" id="UCS" name="options" value="option1" checked>
                UCS
            </label>
            <label>
            <input type="radio" id="A*" name="options" value="option2">
                A*
            </label>
        </div>
        <div class="search-container" id="find-path">
            <button onclick="calculate()">Find Path</button>
        </div>
        <div class="search-container" id="find-path">
            <label id="runtime"></label>
        </div>
    </div>

    <div class="blue-div">
        <button onclick="clearMap()" class="clear-button">Clear Map</button>
        
        <div style="margin-top: 10px; margin-left: 10px; margin-right: 10px;">
            <p>User Guide:</p>
            <ul>
                <li>Ketik lokasi pada searchbar diatas map, lalu tekan 'Go'</li>
                <li>
                    Doubleclick pada ujung
                    jalan atau persimpangan jalan
                    untuk menambah simpul
                </li>
                <li>Klik kanan pada simpul untuk menghapus simpul tersebut</li>
                <li>Klik 2 simpul untuk menambah garis ketetanggaan</li>
                <li>klik 2 simpul yang sudah memiliki garis untuk menghapus garis ketetanggaan</li>
                <li>Hover pada simpul untuk melihat 
                    ID simpul dan masukkan pada 
                    origin dan destination untuk 
                    memulai pencarian
                </li>
                <li>Pilih UCS atau A* sebagai algoritma pencarian</li>
                <li>tekan 'Find Path' untuk mencari jalan terdekat</li>
            </ul>
        </div>
    </div>

</body>
</html>
